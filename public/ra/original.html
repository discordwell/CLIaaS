<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Red Alert - Original WASM</title>
<style>
  * { margin: 0; padding: 0; }
  body { background: #000; overflow: hidden; }
  canvas { display: block; margin: 0 auto; image-rendering: pixelated; }
  #status { color: #ff4400; font-family: monospace; text-align: center; padding: 20px; font-size: 18px; }
  #progress { display: block; margin: 10px auto; width: 300px; }
</style>
</head>
<body>
<div id="status">Loading Red Alert WASM...</div>
<progress id="progress" max="100" value="0"></progress>
<canvas id="canvas" width="320" height="200" oncontextmenu="event.preventDefault()" tabindex="-1"></canvas>
<script>
// === Self-capture + rendering hook system ===
(function() {
  window.__wasmScreenshots = [];
  window.__wasmCaptureQueue = [];
  window.__wasmFrameCount = 0;
  window.__wasmHasContent = false;
  window.__wasmReady = false;
  window.__wasmLogs = [];
  window.__wasmDiag = {};
  window.__wasmRenderCount = 0;      // How many putImageData calls
  window.__wasmRenderSamples = [];   // Sample pixel data from renders

  var MAX_SCREENSHOTS = 100;
  var PERIODIC_INTERVAL = 90;

  function wlog(msg) {
    var entry = '[' + new Date().toISOString() + '] ' + msg;
    window.__wasmLogs.push(entry);
    console.log('WASM-capture: ' + msg);
  }
  window.__wlog = wlog;

  window.__wasmRequestCapture = function(key) {
    window.__wasmCaptureQueue.push(key);
  };

  // Capture uncaught errors
  window.__wasmErrors = [];
  window.addEventListener('error', function(e) {
    var msg = 'UNCAUGHT: ' + (e.message || e) + ' @ ' + (e.filename || '') + ':' + (e.lineno || '');
    window.__wasmErrors.push(msg);
    wlog(msg);
  });
  window.addEventListener('unhandledrejection', function(e) {
    var msg = 'UNHANDLED_REJECTION: ' + (e.reason || e);
    window.__wasmErrors.push(msg);
    wlog(msg);
  });

  // === Hook createImageData to fix 0-dimension SDL2 surface ===
  // The WASM binary's SDL2 passes w=0, h=0 to the EM_ASM rendering function.
  // createImageData(0, 0) would throw IndexSizeError. Substitute the actual
  // game resolution (320x200 for LORES=1) so SDL2.image has the right size
  // and the pixel copy from WASM heap reads the correct frame buffer.
  var origCreateImageData = CanvasRenderingContext2D.prototype.createImageData;
  var GAME_RES_W = 320, GAME_RES_H = 200;
  CanvasRenderingContext2D.prototype.createImageData = function(w, h) {
    if (w <= 0 || h <= 0) {
      wlog('createImageData(' + w + ', ' + h + ') → substituted ' + GAME_RES_W + 'x' + GAME_RES_H);
      return origCreateImageData.call(this, GAME_RES_W, GAME_RES_H);
    }
    if (w > 1 && h > 1) {
      wlog('createImageData(' + w + ', ' + h + ')');
    }
    return origCreateImageData.call(this, w, h);
  };

  // === Hook putImageData to detect SDL2 rendering ===
  var origPutImageData = CanvasRenderingContext2D.prototype.putImageData;
  CanvasRenderingContext2D.prototype.putImageData = function(imageData, dx, dy) {
    window.__wasmRenderCount++;
    // Sample first 20 renders
    if (window.__wasmRenderCount <= 20 || window.__wasmRenderCount % 100 === 0) {
      var data = imageData.data;
      var w = imageData.width, h = imageData.height;
      // Sample center pixel
      var cx = Math.floor(w / 2), cy = Math.floor(h / 2);
      var idx = (cy * w + cx) * 4;
      var centerPx = [data[idx], data[idx+1], data[idx+2], data[idx+3]];
      // Count non-black pixels in a sample
      var nonBlack = 0;
      var totalSampled = 0;
      for (var i = 0; i < data.length && totalSampled < 1000; i += 4 * Math.max(1, Math.floor(data.length / 4000))) {
        totalSampled++;
        if (data[i] > 5 || data[i+1] > 5 || data[i+2] > 5) nonBlack++;
      }
      var sample = {
        render: window.__wasmRenderCount,
        w: w, h: h,
        centerPx: centerPx,
        nonBlack: nonBlack,
        totalSampled: totalSampled,
        at: Date.now()
      };
      window.__wasmRenderSamples.push(sample);
      if (nonBlack > 0 && !window.__wasmHasContent) {
        window.__wasmHasContent = true;
        window.__wasmReady = true;
        wlog('First non-black render! render#' + window.__wasmRenderCount +
             ' nonBlack=' + nonBlack + '/' + totalSampled +
             ' center=' + JSON.stringify(centerPx));
      }
      if (window.__wasmRenderCount <= 5) {
        wlog('putImageData #' + window.__wasmRenderCount +
             ' ' + w + 'x' + h +
             ' center=' + JSON.stringify(centerPx) +
             ' nonBlack=' + nonBlack + '/' + totalSampled);
      }
    }
    return origPutImageData.call(this, imageData, dx, dy);
  };

  // Check 2D canvas pixels
  function hasRealContent(canvas) {
    try {
      var ctx = canvas.getContext('2d');
      if (!ctx) return false;
      var w = canvas.width, h = canvas.height;
      if (w === 0 || h === 0) return false;
      var row = ctx.getImageData(0, Math.floor(h/2), w, 1).data;
      for (var j = 0; j < row.length; j += 4) {
        if (row[j] > 5 || row[j+1] > 5 || row[j+2] > 5) return true;
      }
      return false;
    } catch(e) { return false; }
  }

  function captureFrame(key) {
    var canvas = document.getElementById('canvas');
    if (!canvas) return;
    try {
      var dataUrl = canvas.toDataURL('image/png');
      if (!window.__wasmHasContent) {
        if (hasRealContent(canvas)) {
          window.__wasmHasContent = true;
          window.__wasmReady = true;
          wlog('First real canvas content at frame ' + window.__wasmFrameCount);
        }
      }
      if (window.__wasmScreenshots.length >= MAX_SCREENSHOTS) {
        var evictIdx = window.__wasmScreenshots.findIndex(function(s) {
          return s.key.startsWith('periodic-');
        });
        if (evictIdx >= 0) window.__wasmScreenshots.splice(evictIdx, 1);
        else window.__wasmScreenshots.shift();
      }
      window.__wasmScreenshots.push({
        key: key, dataUrl: dataUrl, timestamp: Date.now(), frame: window.__wasmFrameCount
      });
    } catch (e) { wlog('Capture error: ' + e.message); }
  }

  function logDiagnostics() {
    var canvas = document.getElementById('canvas');
    if (!canvas) return;
    var diag = {
      canvasWidth: canvas.width,
      canvasHeight: canvas.height,
      frameCount: window.__wasmFrameCount,
      hasContent: window.__wasmHasContent,
      renderCount: window.__wasmRenderCount,
    };
    try {
      var ctx = canvas.getContext('2d');
      if (ctx) {
        diag.contextType = '2d';
        var px = ctx.getImageData(Math.floor(canvas.width/2), Math.floor(canvas.height/2), 1, 1).data;
        diag.centerPixel = [px[0], px[1], px[2], px[3]];
      }
    } catch(e) { diag.contextError = e.message; }
    if (window.Module) {
      diag.moduleCtx = !!window.Module.ctx;
      if (window.Module.SDL2) {
        diag.sdl2W = window.Module.SDL2.w;
        diag.sdl2H = window.Module.SDL2.h;
        diag.sdl2HasCtx = !!window.Module.SDL2.ctx;
        diag.sdl2HasAudioCtx = !!window.Module.SDL2.audioContext;
        diag.sdl2HasImage = !!window.Module.SDL2.image;
      }
    }
    window.__wasmDiag = diag;
    wlog('Diagnostics: ' + JSON.stringify(diag));
  }

  function captureLoop() {
    window.__wasmFrameCount++;
    while (window.__wasmCaptureQueue.length > 0) {
      captureFrame(window.__wasmCaptureQueue.shift());
    }
    if (window.__wasmFrameCount % PERIODIC_INTERVAL === 0) {
      captureFrame('periodic-' + window.__wasmFrameCount);
    }
    if (window.__wasmFrameCount % 300 === 1) logDiagnostics();
    requestAnimationFrame(captureLoop);
  }

  setTimeout(function() {
    wlog('Starting capture loop');
    logDiagnostics();
    requestAnimationFrame(captureLoop);
  }, 2000);
})();

// === Intercept WASM imports at binding time ===
// Two critical fixes for headless Chrome:
// 1. _emscripten_set_canvas_element_size: SDL2 calls with (0,0) instead of (320,200)
// 2. _emscripten_get_element_css_size: getBoundingClientRect returns 0x0 in headless,
//    causing SDL2 to allocate a 0-byte pixel buffer (SDL_WINDOW_RESIZABLE reads CSS dims)
(function() {
  var GAME_W = 320, GAME_H = 200;
  var origInstantiate = WebAssembly.instantiate;
  var origInstantiateStreaming = WebAssembly.instantiateStreaming;

  function wrapImports(imports) {
    if (!imports) return imports;
    for (var mod in imports) {
      if (typeof imports[mod] !== 'object') continue;
      var modObj = imports[mod];
      for (var key in modObj) {
        var fn = modObj[key];
        if (typeof fn !== 'function') continue;
        var src = fn.toString();

        // Wrap _emscripten_set_focus_callback_on_thread: capture the C callback
        // so we can manually invoke it to simulate focus gain and unblock
        // the GameInFocus wait loop in init.cpp:3188-3190.
        if (src.indexOf('"focus"') !== -1 && src.indexOf('registerFocusEventCallback') !== -1) {
          if (window.__wlog) window.__wlog('Wrapping WASM import "' + key + '" (focus_callback)');
          modObj[key] = (function(origFn) {
            var wrapper = function(target, userData, useCapture, callbackfunc, targetThread) {
              var result = origFn(target, userData, useCapture, callbackfunc, targetThread);
              if (window.__wlog) window.__wlog('WASM→set_focus_callback(target=' + target + ', cb=' + callbackfunc + ', ud=' + userData + ') result=' + result);
              // Store for deferred focus simulation
              window.__wasmFocusCb = callbackfunc;
              window.__wasmFocusUd = userData;
              // Schedule focus simulation — fires during emscripten_sleep yields
              setTimeout(function simulateFocus() {
                try {
                  if (typeof dynCall_iiii === 'undefined' || typeof _malloc === 'undefined') {
                    setTimeout(simulateFocus, 200);
                    return;
                  }
                  var ev = _malloc(256);
                  // nodeName "CANVAS\0" at offset 0
                  var name = 'CANVAS';
                  for (var i = 0; i < name.length; i++) HEAPU8[ev + i] = name.charCodeAt(i);
                  HEAPU8[ev + name.length] = 0;
                  // id "canvas\0" at offset 128
                  var id = 'canvas';
                  for (var i = 0; i < id.length; i++) HEAPU8[ev + 128 + i] = id.charCodeAt(i);
                  HEAPU8[ev + 128 + id.length] = 0;
                  if (window.__wlog) window.__wlog('Invoking focus callback: dynCall_iiii(' + callbackfunc + ', 13, ' + ev + ', ' + userData + ')');
                  dynCall_iiii(callbackfunc, 13, ev, userData);
                  try { _free(ev); } catch(e2) { /* ev leaked but safe — Asyncify may be mid-unwind */ }
                  if (window.__wlog) window.__wlog('Focus callback invoked successfully!');
                } catch(e) {
                  if (window.__wlog) window.__wlog('Focus simulation error: ' + e.message);
                  // Retry — game might not be ready yet
                  setTimeout(simulateFocus, 500);
                }
              }, 100);
              return result;
            };
            wrapper.isAsync = origFn.isAsync;
            return wrapper;
          })(fn);
        }

        // Wrap _emscripten_set_canvas_element_size: force 320x200 when SDL2 sends 0x0
        if (src.indexOf('findCanvasEventTarget') !== -1 &&
            src.indexOf('getBoundingClientRect') === -1) {
          if (window.__wlog) window.__wlog('Wrapping WASM import "' + key + '" (set_canvas_element_size)');
          modObj[key] = (function(origFn) {
            var wrapper = function(target, width, height) {
              if (width <= 1 && height <= 1) {
                if (window.__wlog) window.__wlog('WASM→set_canvas_size(' + target + ', ' + width + '→' + GAME_W + ', ' + height + '→' + GAME_H + ')');
                return origFn(target, GAME_W, GAME_H);
              }
              return origFn(target, width, height);
            };
            wrapper.isAsync = origFn.isAsync;
            return wrapper;
          })(fn);
        }

        // Wrap _emscripten_get_element_css_size: in headless Chrome,
        // getBoundingClientRect() returns 0x0 because canvas has no layout.
        // SDL2's SDL_WINDOW_RESIZABLE reads CSS dims to set window size,
        // which causes a 0-byte pixel buffer allocation. After calling the
        // original, patch HEAPF64 to return GAME_W x GAME_H if it wrote 0.
        if (src.indexOf('getBoundingClientRect') !== -1 &&
            src.indexOf('HEAPF64') !== -1) {
          if (window.__wlog) window.__wlog('Wrapping WASM import "' + key + '" (get_element_css_size)');
          modObj[key] = (function(origFn) {
            var wrapper = function(target, widthPtr, heightPtr) {
              var result = origFn(target, widthPtr, heightPtr);
              // After the call, check what was written to HEAPF64
              // widthPtr and heightPtr are byte offsets into the HEAP
              try {
                if (typeof HEAPF64 !== 'undefined') {
                  var w = HEAPF64[widthPtr >> 3];
                  var h = HEAPF64[heightPtr >> 3];
                  // NaN-safe check: NaN <= 0 is false, so use !(x > 0) which catches NaN, 0, negative
                  if (!(w > 0) || !(h > 0)) {
                    HEAPF64[widthPtr >> 3] = GAME_W;
                    HEAPF64[heightPtr >> 3] = GAME_H;
                    if (window.__wlog) window.__wlog('WASM→get_css_size: ' + w + 'x' + h + ' → forced ' + GAME_W + 'x' + GAME_H);
                  }
                }
              } catch(e) {
                if (window.__wlog) window.__wlog('WASM→get_css_size patch error: ' + e.message);
              }
              return result;
            };
            wrapper.isAsync = origFn.isAsync;
            return wrapper;
          })(fn);
        }
      }
    }
    return imports;
  }

  WebAssembly.instantiate = function(source, imports) {
    if (window.__wlog) window.__wlog('Intercepted WebAssembly.instantiate');
    return origInstantiate.call(WebAssembly, source, wrapImports(imports));
  };
  if (origInstantiateStreaming) {
    WebAssembly.instantiateStreaming = function(source, imports) {
      if (window.__wlog) window.__wlog('Intercepted WebAssembly.instantiateStreaming');
      return origInstantiateStreaming.call(WebAssembly, source, wrapImports(imports));
    };
  }
})();

// === Patch canvas.getBoundingClientRect for headless browsers ===
// In headless Chrome, getBoundingClientRect() returns all zeros because the canvas
// has no visual layout. SDL2's Emscripten port uses this to determine window size
// (via _emscripten_get_element_css_size). Patch it to return proper dimensions.
(function() {
  var canvas = document.getElementById('canvas');
  if (!canvas) return;
  var origGetBCR = canvas.getBoundingClientRect.bind(canvas);
  canvas.getBoundingClientRect = function() {
    var rect = origGetBCR();
    if (rect.width <= 0 || rect.height <= 0) {
      // Headless: return dimensions matching the CSS style (set by resizeCanvas)
      var w = window.innerWidth || 640;
      var h = window.innerHeight || 400;
      if (window.__wlog) window.__wlog('getBoundingClientRect patched: 0x0 → ' + w + 'x' + h);
      return { left: 0, top: 0, right: w, bottom: h, width: w, height: h, x: 0, y: 0 };
    }
    return rect;
  };
})();

// === Pre-create AudioContext so SDL2 doesn't block ===
(function() {
  var OrigAC = window.AudioContext || window.webkitAudioContext;
  if (!OrigAC) return;
  try {
    var preCtx = new OrigAC();
    preCtx.resume().catch(function(){});
    window.__preAudioCtx = preCtx;
  } catch(e) {}
  function PatchedAC() {
    var ac;
    try { ac = new OrigAC(); ac.resume().catch(function(){}); }
    catch(e) { ac = new OrigAC(); }
    return ac;
  }
  PatchedAC.prototype = OrigAC.prototype;
  window.AudioContext = PatchedAC;
  if (window.webkitAudioContext) window.webkitAudioContext = PatchedAC;
})();

var statusElement = document.getElementById("status");
var progressElement = document.getElementById("progress");
var canvasElement = document.getElementById("canvas");

function resizeCanvas() {
  canvasElement.style.width = window.innerWidth + 'px';
  canvasElement.style.height = window.innerHeight + 'px';
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

window.addEventListener('load', function() {
  // Make canvas focusable and give it focus
  canvasElement.tabIndex = 0;
  canvasElement.focus();
  setTimeout(function() {
    canvasElement.dispatchEvent(new PointerEvent('pointerdown', {bubbles:true, clientX:320, clientY:200}));
    canvasElement.dispatchEvent(new PointerEvent('pointerup', {bubbles:true, clientX:320, clientY:200}));
    canvasElement.dispatchEvent(new MouseEvent('click', {bubbles:true, clientX:320, clientY:200}));
    canvasElement.focus();
    if (window.__preAudioCtx) window.__preAudioCtx.resume().catch(function(){});
  }, 500);

  // Fallback focus simulation: periodically dispatch focus events on the canvas.
  // The Emscripten SDL2 port registers "focus" event listeners on the canvas via
  // emscripten_set_focus_callback. If those listeners were registered, dispatching
  // a FocusEvent should trigger the C callback that sets GameInFocus = true.
  var focusAttempts = 0;
  var focusInterval = setInterval(function() {
    focusAttempts++;
    canvasElement.dispatchEvent(new FocusEvent('focus', { bubbles: true }));
    canvasElement.dispatchEvent(new FocusEvent('focusin', { bubbles: true }));
    canvasElement.focus();
    // Also dispatch on window/document for SDL2 ports that listen there
    window.dispatchEvent(new Event('focus'));
    document.dispatchEvent(new Event('visibilitychange'));
    if (focusAttempts > 60) clearInterval(focusInterval); // Stop after 30s
  }, 500);
});

var Module = {
  preRun: [function() {
    var wlog = window.__wlog || function(m) { console.log('preRun: ' + m); };

    // Fix Emscripten event target resolution: specialHTMLTargets[0] is initialized
    // to 0 (falsy) by the runtime, so emscripten_set_*_callback(0, ...) calls
    // (target=0 meaning "default canvas") fail to register any event listeners.
    // Patch it here — after runtime init but before main() — so SDL2 input works.
    if (typeof specialHTMLTargets !== 'undefined') {
      specialHTMLTargets[0] = Module.canvas;
      wlog('preRun: patched specialHTMLTargets[0] = <' + Module.canvas.tagName + ' ' +
           Module.canvas.width + 'x' + Module.canvas.height + '>');
    } else {
      wlog('preRun: specialHTMLTargets not defined yet');
    }

    // Hook _emscripten_set_canvas_element_size for diagnostics
    if (typeof _emscripten_set_canvas_element_size === 'function') {
      var origSetSize = _emscripten_set_canvas_element_size;
      _emscripten_set_canvas_element_size = function(target, width, height) {
        wlog('_emscripten_set_canvas_element_size(' + target + ', ' + width + ', ' + height + ')');
        var result = origSetSize(target, width, height);
        wlog('  → result=' + result + ' canvas=' + Module.canvas.width + 'x' + Module.canvas.height);
        return result;
      };
      wlog('preRun: hooked _emscripten_set_canvas_element_size');
    } else {
      wlog('preRun: _emscripten_set_canvas_element_size not yet defined');
    }

    // Override _emscripten_get_element_css_size to return proper dimensions.
    // CRITICAL FIX: Emscripten's internal getBoundingClientRect helper returns
    // {left:0, top:0} (NO width/height) when the target is in specialHTMLTargets.
    // Since we patched specialHTMLTargets[0] = canvas for event handling, this
    // causes rect.width = undefined → NaN in HEAPF64. SDL2's SDL_WINDOW_RESIZABLE
    // reads these values to set window dimensions, resulting in a 0-byte pixel buffer.
    if (typeof _emscripten_get_element_css_size === 'function') {
      var origGetCssSize = _emscripten_get_element_css_size;
      _emscripten_get_element_css_size = function(target, widthPtr, heightPtr) {
        var result = origGetCssSize(target, widthPtr, heightPtr);
        // Check if valid values were written (guard against NaN from missing rect properties)
        if (typeof HEAPF64 !== 'undefined') {
          var w = HEAPF64[widthPtr >> 3];
          var h = HEAPF64[heightPtr >> 3];
          if (!(w > 0) || !(h > 0) || isNaN(w) || isNaN(h)) {
            HEAPF64[widthPtr >> 3] = GAME_W;
            HEAPF64[heightPtr >> 3] = GAME_H;
            wlog('_emscripten_get_element_css_size: ' + w + 'x' + h + ' → forced ' + GAME_W + 'x' + GAME_H);
          }
        }
        return result;
      };
      wlog('preRun: hooked _emscripten_get_element_css_size');
    } else {
      wlog('preRun: _emscripten_get_element_css_size not yet defined');
    }

    // Intercept canvas.width/height — the WASM binary calls
    // _emscripten_set_canvas_element_size(0, 0, 0) and (0, 1, 1) during init
    // instead of the actual game resolution. Substitute 640x400 for any 0/1 values,
    // and log all writes for diagnostics.
    var canvas = Module.canvas;
    var _widthDesc = Object.getOwnPropertyDescriptor(HTMLCanvasElement.prototype, 'width');
    var _heightDesc = Object.getOwnPropertyDescriptor(HTMLCanvasElement.prototype, 'height');
    // Match the LORES=1 game resolution (320x200 internal, CSS scales to window)
    var GAME_W = 320, GAME_H = 200;
    var _dimSetCount = 0;
    Object.defineProperty(canvas, 'width', {
      get: function() { return _widthDesc.get.call(this); },
      set: function(v) {
        _dimSetCount++;
        if (v <= 1 && _dimSetCount <= 30) {
          // WASM init sends 0 or 1 — substitute actual game resolution
          wlog('canvas.width = ' + v + ' → forced to ' + GAME_W + ' (set #' + _dimSetCount + ')');
          v = GAME_W;
        } else if (_dimSetCount <= 10) {
          wlog('canvas.width = ' + v + ' (set #' + _dimSetCount + ')');
        }
        _widthDesc.set.call(this, v);
      },
      configurable: true
    });
    Object.defineProperty(canvas, 'height', {
      get: function() { return _heightDesc.get.call(this); },
      set: function(v) {
        if (v <= 1 && _dimSetCount <= 30) {
          wlog('canvas.height = ' + v + ' → forced to ' + GAME_H);
          v = GAME_H;
        } else if (_dimSetCount <= 10) {
          wlog('canvas.height = ' + v);
        }
        _heightDesc.set.call(this, v);
      },
      configurable: true
    });

    // Patch the SDL2 rendering EM_ASM function to fix w=0, h=0 from C code.
    // The EM_ASM at address 204400 receives ($0=w, $1=h, $2=pixels) from C.
    // SDL2 internally stores 0x0 dimensions, so w=0 and h=0 are passed.
    // Wrap it to substitute the actual game resolution (320x200).
    if (typeof ASM_CONSTS !== 'undefined' && ASM_CONSTS[204400]) {
      var origRenderASM = ASM_CONSTS[204400];
      ASM_CONSTS[204400] = function($0, $1, $2) {
        var w = $0 <= 0 ? 320 : $0;
        var h = $1 <= 0 ? 200 : $1;
        return origRenderASM(w, h, $2);
      };
      wlog('preRun: patched ASM_CONSTS[204400] (SDL2 render) to fix 0x0 dimensions');
    } else {
      wlog('preRun: ASM_CONSTS[204400] not found, scanning for SDL2 render EM_ASM...');
      // Fallback: scan all ASM_CONSTS for the SDL2 rendering function
      if (typeof ASM_CONSTS !== 'undefined') {
        for (var addr in ASM_CONSTS) {
          var fn = ASM_CONSTS[addr];
          if (typeof fn === 'function' && fn.toString().indexOf('putImageData') !== -1) {
            var origFn = ASM_CONSTS[addr];
            ASM_CONSTS[addr] = function($0, $1, $2) {
              var w = $0 <= 0 ? 320 : $0;
              var h = $1 <= 0 ? 200 : $1;
              return origFn(w, h, $2);
            };
            wlog('preRun: patched ASM_CONSTS[' + addr + '] (SDL2 render fallback)');
            break;
          }
        }
      }
    }

    // Trace event listener registration and handler invocation
    var origAddEventListener = canvas.addEventListener.bind(canvas);
    var handlerMap = {};
    canvas.addEventListener = function(type, handler, options) {
      wlog('canvas.addEventListener("' + type + '", ...) registered');
      // Wrap mouse handlers to log when they fire
      if (type === 'mousedown' || type === 'mousemove') {
        var origHandler = handler;
        var wrappedCount = 0;
        handler = function(e) {
          wrappedCount++;
          if (type === 'mousedown' || wrappedCount <= 5) {
            wlog('canvas.' + type + ' handler FIRED: clientX=' + e.clientX +
                 ' clientY=' + e.clientY + ' trusted=' + e.isTrusted +
                 ' button=' + e.button);
          }
          return origHandler.call(this, e);
        };
      }
      return origAddEventListener(type, handler, options);
    };
    // Also trace on document
    var origDocAddEventListener = document.addEventListener.bind(document);
    document.addEventListener = function(type, handler, options) {
      if (type.indexOf('mouse') !== -1 || type.indexOf('key') !== -1 || type.indexOf('pointer') !== -1) {
        wlog('document.addEventListener("' + type + '", ...) registered');
        if (type === 'mouseup') {
          var origHandler = handler;
          handler = function(e) {
            wlog('document.mouseup handler FIRED: clientX=' + e.clientX +
                 ' clientY=' + e.clientY + ' trusted=' + e.isTrusted);
            return origHandler.call(this, e);
          };
        }
      }
      return origDocAddEventListener(type, handler, options);
    };
    // Also check window for keyboard events
    var origWinAddEventListener = window.addEventListener.bind(window);
    window.addEventListener = function(type, handler, options) {
      if (type.indexOf('key') !== -1 || type.indexOf('mouse') !== -1) {
        wlog('window.addEventListener("' + type + '", ...) registered');
      }
      return origWinAddEventListener(type, handler, options);
    };

    wlog('preRun: complete, canvas=' + canvas.width + 'x' + canvas.height);
  }],
  print: function() {
    var msg = Array.from(arguments).join(' ');
    console.log(msg);
    if (window.__wlog) window.__wlog('WASM: ' + msg);
  },
  printErr: function() {
    var msg = Array.from(arguments).join(' ');
    console.error(msg);
    if (window.__wlog) window.__wlog('WASM-ERR: ' + msg);
  },
  canvas: canvasElement,
  setStatus: function(text) {
    if (text) {
      statusElement.textContent = text;
      var m = text.match(/\((\d+)\/(\d+)\)/);
      if (m) { progressElement.value = parseInt(m[1]); progressElement.max = parseInt(m[2]); }
    } else {
      statusElement.style.display = 'none';
      progressElement.style.display = 'none';
      if (window.__wlog) window.__wlog('Module.setStatus cleared — WASM loaded');
      if (window.__wasmRequestCapture) window.__wasmRequestCapture('wasm-loaded');
    }
  },
  totalDependencies: 0,
  monitorRunDependencies: function(left) {
    this.totalDependencies = Math.max(this.totalDependencies, left);
    Module.setStatus(left ? 'Preparing... (' + (this.totalDependencies-left) + '/' + this.totalDependencies + ')' : 'All downloads complete.');
  }
};
Module.setStatus('Downloading...');

// === Diagnostic: wrap dynCall_iiii to trace mouse callback execution ===
// The mousedown handler calls dynCall_iiii(callbackfunc, eventType, eventStruct, userData).
// This wrapper logs mouse-related calls with coordinate data from the WASM heap.
// fillMouseEventData writes: canvasX @ offset 160 (f64), canvasY @ offset 168 (f64),
// clientX @ offset 192 (f64), clientY @ offset 200 (f64).
(function() {
  var installed = false;
  window.__mouseDiag = { calls: [], lastClick: null };

  window.__getMouseDiag = function() {
    return JSON.parse(JSON.stringify(window.__mouseDiag));
  };

  function tryInstall() {
    if (installed) return;
    if (typeof dynCall_iiii !== 'function') {
      setTimeout(tryInstall, 200);
      return;
    }
    installed = true;
    var origDynCall = dynCall_iiii;
    var mouseCallCount = 0;
    dynCall_iiii = function(func, a1, a2, a3) {
      // Event type IDs: mousedown=5, mouseup=6, mousemove=8, focus=13
      if (a1 >= 5 && a1 <= 8) {
        mouseCallCount++;
        var asyncState = typeof Asyncify !== 'undefined' ? Asyncify.state : 'N/A';
        var coords = null;
        // Read coordinates from the event struct in WASM heap.
        // EmscriptenMouseEvent struct (wasm32): fields are int32 (HEAP32),
        // not float64. Dump first 20 int32s to find the right offsets.
        var rawInts = null;
        try {
          if (typeof HEAP32 !== 'undefined' && a2) {
            rawInts = [];
            for (var ri = 0; ri < 20; ri++) {
              rawInts.push(HEAP32[(a2 >> 2) + ri]);
            }
            // Exact layout from rasdl.js fillMouseEventData:
            // HEAPF64[eventStruct>>3] = timeStamp        (offset 0, 8 bytes)
            // HEAP32[idx+2] = screenX                    (offset 8)
            // HEAP32[idx+3] = screenY                    (offset 12)
            // HEAP32[idx+4] = clientX                    (offset 16)
            // HEAP32[idx+5] = clientY                    (offset 20)
            // HEAP8[+24..27] = ctrl/shift/alt/meta       (offset 24-27)
            // HEAP16 = button/buttons                    (offset 28-31)
            // HEAP32[idx+8] = movementX                  (offset 32)
            // HEAP32[idx+9] = movementY                  (offset 36)
            // HEAP32[idx+10] = clientX - rect.left       (offset 40 = canvasX)
            // HEAP32[idx+11] = clientY - rect.top        (offset 44 = canvasY)
            coords = {
              screenX: HEAP32[(a2 + 8) >> 2],
              screenY: HEAP32[(a2 + 12) >> 2],
              clientX: HEAP32[(a2 + 16) >> 2],
              clientY: HEAP32[(a2 + 20) >> 2],
              canvasX: HEAP32[(a2 + 40) >> 2],
              canvasY: HEAP32[(a2 + 44) >> 2]
            };
          }
        } catch(e) { /* heap read failed */ }

        var entry = {
          call: mouseCallCount,
          func: func,
          type: a1,
          asyncState: asyncState,
          coords: coords,
          timestamp: Date.now()
        };

        if (a1 === 5) { // mousedown
          window.__mouseDiag.lastClick = entry;
        }
        if (mouseCallCount <= 50) {
          window.__mouseDiag.calls.push(entry);
        }

        if (mouseCallCount <= 30) {
          var coordStr = coords ?
            ' client=(' + coords.clientX + ',' + coords.clientY + ')' +
            ' target=(' + coords.targetX + ',' + coords.targetY + ')' +
            ' canvas=(' + coords.canvasX + ',' + coords.canvasY + ')' : '';
          var rawStr = (rawInts && mouseCallCount <= 5) ? ' RAW=' + JSON.stringify(rawInts) : '';
          console.log('dynCall_iiii MOUSE: func=' + func + ' type=' + a1 +
                      ' Asyncify.state=' + asyncState + coordStr + rawStr);
        }
      }
      // CRITICAL: Re-throw Asyncify unwind/rewind exceptions.
      // Asyncify works by throwing a special exception to unwind the JS stack.
      // Catching it breaks the unwind/rewind cycle and permanently stalls WASM.
      try {
        var result = origDynCall(func, a1, a2, a3);
        if (a1 >= 5 && a1 <= 8 && mouseCallCount <= 30) {
          console.log('dynCall_iiii MOUSE result=' + result);
        }
        return result;
      } catch(e) {
        // Re-throw Asyncify exceptions (they use a specific marker)
        if (typeof Asyncify !== 'undefined' && Asyncify.state !== 0) {
          throw e;
        }
        // Only catch non-Asyncify errors
        console.error('dynCall_iiii ERROR: func=' + func + ' type=' + a1 + ' err=' + e.message);
        return 0;
      }
    };
    console.log('dynCall_iiii wrapper installed (traces mouse events with coordinates)');
  }
  setTimeout(tryInstall, 1000);
})();

// === Input injection via WASM exports (autoplay only) ===
// The WASM binary now exports C functions (via EMSCRIPTEN_KEEPALIVE) that
// call Keyboard->Put() directly from within the C++ code. This bypasses
// SDL event handling and Asyncify constraints that broke all previous
// approaches (CDP keyboard, CDP mouse, JS memory injection).
//
// Exported functions (accessible as Module._inject_*):
//   _inject_key(vk_code)                    → key press + release
//   _inject_key_press(vk_code)              → key press only
//   _inject_key_release(vk_code)            → key release only
//   _inject_mouse_click(game_x, game_y, btn) → mouse press + release at coords
//   _inject_mouse_press(game_x, game_y, btn) → mouse press only
//   _inject_mouse_release(game_x, game_y, btn) → mouse release only
//   _inject_mouse_move(game_x, game_y)      → update cursor position
//   _input_diag()                           → 1 if buffer has data, 0 if empty
//
// VK codes (SDL scancode-based, from keyboard.h):
//   VK_LBUTTON=1, VK_RBUTTON=2, VK_RETURN=40, VK_ESCAPE=41, VK_SPACE=44
(function() {
  var params = new URLSearchParams(window.location.search);
  if (!params.get('autoplay')) return;

  // --- Public API: thin wrappers around Module._inject_* exports ---

  window.__injectKey = function(vkCode) {
    if (!Module || !Module._inject_key) {
      console.log('[input-inject] Module._inject_key not available yet');
      return false;
    }
    var result = Module._inject_key(vkCode);
    console.log('[input-inject] inject_key(' + vkCode + ') → ' + result);
    return result === 1;
  };

  window.__injectKeyPress = function(vkCode) {
    if (!Module || !Module._inject_key_press) return false;
    return Module._inject_key_press(vkCode) === 1;
  };

  window.__injectKeyRelease = function(vkCode) {
    if (!Module || !Module._inject_key_release) return false;
    return Module._inject_key_release(vkCode) === 1;
  };

  window.__injectMouseClick = function(gameX, gameY, button) {
    button = button || 1;
    if (!Module || !Module._inject_mouse_click) {
      console.log('[input-inject] Module._inject_mouse_click not available yet');
      return false;
    }
    var result = Module._inject_mouse_click(gameX, gameY, button);
    console.log('[input-inject] inject_mouse_click(' + gameX + ',' + gameY + ',' + button + ') → ' + result);
    return result === 1;
  };

  window.__injectMousePress = function(gameX, gameY, button) {
    button = button || 1;
    if (!Module || !Module._inject_mouse_press) return false;
    return Module._inject_mouse_press(gameX, gameY, button) === 1;
  };

  window.__injectMouseRelease = function(gameX, gameY, button) {
    button = button || 1;
    if (!Module || !Module._inject_mouse_release) return false;
    return Module._inject_mouse_release(gameX, gameY, button) === 1;
  };

  window.__injectMouseMove = function(gameX, gameY) {
    if (!Module || !Module._inject_mouse_move) return false;
    return Module._inject_mouse_move(gameX, gameY) === 1;
  };

  // Check if the input injection system is ready (WASM exports available)
  window.__inputReady = function() {
    return !!(Module && Module._inject_key);
  };

  // Enable autoplay mode: BGMessageBox auto-dismisses, movies skip
  window.__setAutoplay = function(mode) {
    if (!Module || !Module._set_autoplay) {
      console.log('[input-inject] Module._set_autoplay not available yet');
      return false;
    }
    var prev = Module._set_autoplay(mode ? 1 : 0);
    console.log('[input-inject] set_autoplay(' + (mode ? 1 : 0) + ') → prev=' + prev);
    return true;
  };

  // Get diagnostic info
  window.__inputDiag = function() {
    if (!Module || !Module._input_diag) return { ready: false };
    return {
      ready: true,
      hasData: Module._input_diag()
    };
  };
})();

// === Briefing text suppressor (autoplay only) ===
// The WASM game's briefing dialog (BGMessageBox) blocks waiting for user input.
// CDP keyboard/mouse events cannot reliably dismiss it due to Asyncify constraints.
// Solution: zero out the briefing text in WASM heap memory so Restate_Mission()
// skips the dialog entirely (it checks strlen(Scen.BriefingText) > 0).
//
// The scanner runs periodically during scenario loading. Between Read_Scenario_INI
// (which fills BriefingText) and Restate_Mission (which displays it), the game
// yields to the browser via Call_Back()/emscripten_sleep, giving us a window.
(function() {
  var params = new URLSearchParams(window.location.search);
  if (!params.get('autoplay')) return;

  // The briefing text starts with "Rescue Einstein" (ant missions).
  // We search for it in WASM heap and zero the first byte → strlen returns 0.
  var MARKER = "Rescue Einstein";
  var markerBytes = [];
  for (var i = 0; i < MARKER.length; i++) markerBytes.push(MARKER.charCodeAt(i));

  var patched = false;
  var scanCount = 0;

  function scanAndPatch() {
    if (patched || typeof HEAPU8 === 'undefined') {
      if (!patched) setTimeout(scanAndPatch, 50);
      return;
    }
    scanCount++;
    var heap = HEAPU8;
    var patchCount = 0;

    // Search for the marker string in WASM heap.
    // The briefing text is in Scen.BriefingText (a char[1024] buffer).
    // It's also in the INI data loaded from MIX, but zeroing BriefingText is enough.
    // Search from high addresses first (stack/heap data, not code/static).
    for (var addr = heap.length - MARKER.length; addr >= 0; addr--) {
      var match = true;
      for (var j = 0; j < markerBytes.length; j++) {
        if (heap[addr + j] !== markerBytes[j]) { match = false; break; }
      }
      if (match) {
        // Zero out the first byte — strlen() will return 0
        heap[addr] = 0;
        patchCount++;
        console.log('[briefing-suppress] Zeroed briefing text at heap offset ' + addr + ' (scan #' + scanCount + ')');
      }
    }

    if (patchCount > 0) {
      patched = true;
      console.log('[briefing-suppress] Patched ' + patchCount + ' briefing text locations');
    } else if (scanCount < 600) {
      // Keep scanning for up to 30s (600 * 50ms)
      setTimeout(scanAndPatch, 50);
    } else {
      console.log('[briefing-suppress] Gave up after ' + scanCount + ' scans');
    }
  }

  // Start scanning once WASM is loaded
  var origSetStatus = Module.setStatus;
  var scanning = false;
  Module.setStatus = function(text) {
    origSetStatus.call(Module, text);
    if (!text && !scanning) {
      scanning = true;
      console.log('[briefing-suppress] WASM loaded, starting briefing text scanner');
      setTimeout(scanAndPatch, 100);
    }
  };
})();

// === Autoplay coordination ===
// Activated by ?autoplay=ants (or ?autoplay=allies).
// Provides screen detection helpers for Playwright test. Menu navigation
// is driven externally by Playwright via CDP keyboard.press() events.
//
// IMPORTANT: Do NOT dispatch keyboard events from page-level timers.
// Page-dispatched KeyboardEvents cause the WASM main thread to block
// permanently (ASYNCIFY's unwind/rewind cycle gets disrupted). Only
// Playwright's trusted CDP keyboard events work for menu navigation.
(function() {
  var params = new URLSearchParams(window.location.search);
  var autoplay = params.get('autoplay');
  if (!autoplay) return;

  window.__wasmGameplayStarted = false;
  window.__autoplayState = 'waiting-for-content';
  window.__autoplayLog = [];
  window.__autoplayScreenChanges = 0;

  function alog(msg) {
    var entry = '[autoplay ' + new Date().toISOString() + '] ' + msg;
    window.__autoplayLog.push(entry);
    console.log(entry);
  }

  // --- Screen detection helpers ---
  window.__getScreenHash = function() {
    var canvas = document.getElementById('canvas');
    if (!canvas) return '';
    try {
      var ctx = canvas.getContext('2d');
      if (!ctx) return '';
      var hash = '';
      for (var sy = 0; sy < 4; sy++) {
        for (var sx = 0; sx < 4; sx++) {
          var px = ctx.getImageData(
            Math.floor(canvas.width * (sx + 0.5) / 4),
            Math.floor(canvas.height * (sy + 0.5) / 4),
            1, 1
          ).data;
          hash += String.fromCharCode(px[0] & 0xF0, px[1] & 0xF0, px[2] & 0xF0);
        }
      }
      return hash;
    } catch(e) { return ''; }
  };

  window.__getNonBlackCount = function() {
    var canvas = document.getElementById('canvas');
    if (!canvas) return 0;
    try {
      var ctx = canvas.getContext('2d');
      if (!ctx) return 0;
      var w = canvas.width, h = canvas.height;
      var data = ctx.getImageData(0, 0, w, h).data;
      var count = 0;
      var step = Math.max(4, Math.floor(data.length / 4000)) * 4;
      for (var i = 0; i < data.length; i += step) {
        if (data[i] > 10 || data[i+1] > 10 || data[i+2] > 10) count++;
      }
      return count;
    } catch(e) { return 0; }
  };

  // --- Screen monitoring ---
  // Tracks screen changes passively (no keyboard dispatches).
  // Menu navigation is handled by the Playwright test.
  var lastHash = '';

  function startMonitoring() {
    window.__autoplayState = 'monitoring';
    lastHash = window.__getScreenHash();
    alog('Monitoring started');

    function checkScreen() {
      var newHash = window.__getScreenHash();
      if (newHash !== lastHash && newHash !== '') {
        window.__autoplayScreenChanges++;
        lastHash = newHash;
        if (window.__wasmRequestCapture) window.__wasmRequestCapture('screen-change-' + window.__autoplayScreenChanges);
      }
      setTimeout(checkScreen, 2000);
    }
    setTimeout(checkScreen, 2000);
  }

  // --- Content detection and startup ---
  var stateStartTime = Date.now();

  function tick() {
    if (window.__autoplayState === 'waiting-for-content') {
      if (window.__wasmHasContent || window.__getNonBlackCount() > 50) {
        alog('Content detected, starting screen monitoring...');
        window.__autoplayState = 'content-detected';
        setTimeout(startMonitoring, 3000);
      } else if (Date.now() - stateStartTime > 120000) {
        alog('TIMEOUT waiting for content');
        window.__autoplayState = 'failed';
        window.__wasmGameplayStarted = true;
        return;
      } else {
        setTimeout(tick, 500);
      }
    }
  }

  // Start detection after WASM loads
  var origSetStatus = Module.setStatus;
  Module.setStatus = function(text) {
    origSetStatus.call(Module, text);
    if (!text && window.__autoplayState === 'waiting-for-content') {
      alog('WASM loaded, starting content detection...');
      setTimeout(function() { tick(); }, 3000);
    }
  };

  // Fallback: start after 30s even if setStatus never clears
  setTimeout(function() {
    if (window.__autoplayState === 'waiting-for-content') {
      alog('Fallback: starting detection after 30s timeout');
      tick();
    }
  }, 30000);
})();
</script>
<script src="gamedata.js"></script>
<script async src="rasdl.js"></script>
</body>
</html>
